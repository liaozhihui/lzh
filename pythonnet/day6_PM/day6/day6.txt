前情回顾

1.  创建进程方法 ：  os.fork() 

2.  进程相关函数
		os.getpid()   获取进程PID
		os.getppid()  获取父进程PID
		os._exit()    进程退出
		sys.exit()    进程退出

3.  孤儿进程和僵尸进程

    * 如何避免僵尸进程？
			1. 使用wait  waitpid回收子进程
			2. 创建二级子进程
			3. 使用signal处理子进程退出信号

4.  聊天室程序
		
		确定需求--》确定基本技术点--》整体设计--》功能分析--》代码实现--》基本测试
********************************************************

一. 群聊聊天室（续）

  1. 退出功能
	  【1】 服务端
				* 接收消息确定消息类型
				* 将用户从字典移除
				* 将退出消息发送给其他人
				* 给该用户发送特殊标志

		【2】 客户端
		    * 输入quit表示退出
				* 将退出请求发送给服务器然后结束进程
				* recv 接收服务器消息后退出进程

  2. 管理员消息


二. multiprocessing 模块创建进程

	1. 流程特点 
	  【1】 将需要子进程执行的事件封装为函数
		【2】 通过模块的Process类创建进程对象，关联函数
		【3】 可以通过进程对象设置进程信息及属性
		【4】 通过进程对象调用start启动进程
		【5】 通过进程对象调用join回收进程
	
	2. 基本接口使用

	  【1】 Process()
					功能 ： 创建进程对象
					参数 ： target 绑定要执行的目标函数 
									args 元组，用于给target函数位置传参
									kwargs 字典，给target函数键值传参
		
		【2】 p.start()
					功能 ： 启动进程

					* 启动进程此时target绑定函数开始执行，该函数作为子进程执行内容，此时进程真正被创建
		
		【3】 p.join([timeout])
					功能：阻塞等待回收进程
					参数：超时时间

    注意：* 使用multiprocessing创建进程同样是子进程复制父				进程空间代码段，父子进程运行互不影响。
					* 子进程只运行target绑定的函数部分，其余内容均是父进程执行内容。
					* multiprocessing中父进程往往只用来创建子进程回收子进程，具体事件由子进程完成。
					* multiprocessing创建的子进程中无法使用标准输入


  3. 进程对象属性

	  p.name  进程名称
		
		p.pid   对应子进程的PID号
		
		p.is_alive() 查看子进程是否在生命周期
		
		p.daemon  设置父子进程的退出关系  
			* 如果设置为True则子进程会随父进程的退出而结束
			* 要求必须在start()前设置
			* 如果daemon设置成True 通常就不会使用 join()


  4. 自定义进程类
		
		编写流程：

	  【1】 定义进程类继承Process
		【2】 编写自己的__init__方法，使用super重新加载父类__init__方法
		【3】 重写Process中的run方法

		使用方法：

		【1】 使用自定义类实例化对象
		【2】 通过实例对象调用start()创建进程，自动运行run
		【3】 实例对象调用join()回收子进程


三.  进程池技术

	1.  必要性
	  【1】 进程的创建和销毁过程消耗的资源较多
		【2】 当任务量众多，每个任务在很短时间内完成时，需要频繁的创建和销毁进程。此时对计算机压力较大
		【3】 进程池技术很好的解决了以上问题。
	
	2.  原理 ： 创建一定数量的进程来处理事件，事件处理完进	程不退出而是继续处理其他事件，直到所有事件全都处理完毕统一销毁。增加进程的重复利用，降低资源消耗。


	3. 进程池实现

	  【1】 创建进程池对象，放入适当的进程
		  
			from multiprocessing import Pool

			Pool(processes)
			功能： 创建进程池对象
			参数： 指定进程数量，默认根据系统自动判定
		
		【2】 将事件加入进程池队列执行

		  pool.apply_async(func,args,kwds)
			功能: 使用进程池执行 func事件
			参数： func 事件函数
						 args 元组  给func按位置传参
						 kwds 字典  给func按照键值传参
			返回值： 返回函数事件对象
		
		【3】 关闭进程池
		  
			pool.close()
			功能： 关闭进程池
		
		【4】 回收进程池中进程

		  pool.join()
			功能： 回收进程池中进程


		【5】 通过map添加进程池事件

		  pool.map(func,iter)
			功能： 将要做的事件加入进程池
			参数： func  事件函数
			       iter  迭代对象，将迭代值传给func
			返回值： 得到函数返回值列表


四.  进程间通信（IPC）

  1. 必要性： 进程间空间独立，资源不共享，此时在需要进程间数据传输时就需要特定的手段进行数据通信。

	2. 进程间通信方法：
		 管道  消息队列  共享内存  信号  信号量  套接字 

  
	3.  管道通信(Pipe)

		【1】 通信原理 ： 在内存中开辟管道空间，生成管道操作对象，多个进程使用同一个管道对象进行读写即可实现通信

		【2】 实现方法

		  from  multiprocessing import Pipe

			fd1,fd2 = Pipe(duplex = True)
			功能: 创建管道
			参数：默认表示双向管道
						如果为False 表示单向管道
			返回值：表示管道两端的读写对象
							如果是双向管道均可读写
							如果是单向管道fd1只读  fd2只写
			
			fd.recv()
			功能 ： 从管道获取内容
			返回值：获取到的数据

			fd.send(data)
			功能： 向管道写入内容
			参数： 要写入的数据


  4. 消息队列

	  【1】 通信原理：在内存中建立队列模型，进程通过队列将消息存入，或者从队列取出完成进程间通信。

		【2】 实现方法

		  from multiprocessing import Queue

			q = Queue(maxsize=0)
			功能: 创建队列对象
			参数：最多存放消息个数
			返回值：队列对象

			q.put(data,[block,timeout])
			功能：向队列存入消息
			参数：data  要存入的内容
						block  设置是否阻塞 False为非阻塞
						timeout  超时检测
				
			q.get([block,timeout])
			功能：从队列取出消息
			参数：block  设置是否阻塞 False为非阻塞
						timeout  超时检测
			返回值： 返回获取到的内容

			q.full()   判断队列是否为满
			q.empty()  判断队列是否为空
			q.qsize()  获取队列中消息个数
			q.close()  关闭队列
		

作业 ： 1. 父子进程共同复制一个文件，分别复制文件上半部分	
					 和下半部分到另一个新文件中。
				2. 类的设计和函数传参复习
				3. 梳理网络聊天室思路











