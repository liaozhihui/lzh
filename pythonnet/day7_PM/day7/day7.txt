前情回顾

1. multiprocessing模块创建进程

   Process(target,args,kwargs)  创建进程对象
	 p.start()  启动进程
	 p.join()  回收进程

2. 进程对象属性
   p.name  p.pid   p.is_alive()   p.daemon

3. 自定义进程类 ： 继承Process  重写__init__ 和 run

4. 进程池：当有大量的小任务需要多进程完成，进程池可以避免频繁创建销毁进程带来的资源消耗。

   Pool()  创建进程池对象
	 apply_async()  将事件使用进程池执行
	 close() 关闭进程池
	 join()  回收进程池
	 map()   使用迭代对象为进程函数传参后加入进程池

5. 进程间通信
	
	 【1】 管道 ： Pipe()  fd.recv()  fd.send()
	 【2】 消息队列 ：Queue()  q.get()  q.put()  q.full()
										q.empty()  q.qsize()  q.close()

**********************************************************

一. 进程间通信（续）

	1. 共享内存

	  【1】 通信原理：在内中开辟一块空间，进程可以写入内容和读取内容完成通信，但是每次写入内容会覆盖之前内容。

		【2】 实现方法

		  from multiprocessing import Value,Array

			obj = Value(ctype,data)
			功能 ： 开辟共享内存
			参数 ： ctype  表示共享内存空间类型 'i'  'f'  'c'
							data   共享内存空间初始数据
			返回值：共享内存对象

			obj.value  对该属性的修改查看即对共享内存读写


			obj = Array(ctype,data)
			功能： 开辟共享内存空间
			参数： ctype  表示共享内存数据类型
						 data   整数则表示开辟空间的大小，其他数据类型				表示开辟空间存放的初始化数据
			返回值：共享内存对象

			Array共享内存读写： 通过遍历obj可以得到每个值，直接可以通过索引序号修改任意值。

			* 可以使用obj.value直接打印共享内存中的字节串
			
	2. 信号量（信号灯集）

	  【1】 通信原理 ： 给定一个数量对多个进程可见。多个进程都可以操作该数量增减，并根据数量值决定自己的行为。
	
		【2】 实现方法
		  
			from multiprocessing import Semaphore

			sem = Semaphore(num)
			功能 ： 创建信号量对象
			参数 ： 信号量的初始值
			返回值 ： 信号量对象

			sem.acquire()  将信号量减1 当信号量为0时阻塞
			sem.release()  将信号量加1
			sem.get_value() 获取信号量数量
			

补充 ： 当在父进程中创建套接字，进程间通信对象，文件对象，子进程从父进程获取这些对象时，那么对对象的操作会有属性的相互关联影响。如果在各自进程中单独创建这些对象，则各自互不影响。		

二. 线程编程（Thread）

  1. 什么是线程
	  【1】 线程被称为轻量级的进程
		【2】 线程也可以使用计算机多核资源，是多任务编程方式
		【3】 线程是系统分配内核的最小单元
		【4】 线程可以理解为进程的分支任务
	
	2. 线程特征
		【1】 一个进程中可以包含多个线程
		【2】 线程也是一个运行行为，消耗计算机资源
		【3】 一个进程中的所有线程共享这个进程的资源
		【4】 多个线程之间的运行互不影响各自运行
		【5】 线程的创建和销毁消耗资源远小于进程
		【6】 各个线程也有自己的ID等特征

  3. threading模块创建线程

		【1】 创建线程对象
		  
			from threading import Thread 

			t = Thread()
			功能：创建线程对象
			参数：target 绑定线程函数
						args   元组 给线程函数位置传参
						kwargs 字典 给线程函数键值传参
		
		【2】 启动线程
		
		  t.start()

		【3】 回收线程

		  t.join([timeout])

  4. 线程对象属性

	  t.name 线程名称
		t.setName()  设置线程名称
		t.getName()  获取线程名称

		t.is_alive()  查看线程是否在生命周期

		t.daemon  设置主线程和分支线程的退出关系
		t.setDaemon()  设置daemon属性值
		t.isDaemon()  查看daemon属性值
		* daemon为True时主线程退出分支线程也退出。要在start前设置，通常不和join一起使用。

	
	5. 自定义线程类

		【1】 创建步骤
				1. 继承Thread类
				2. 重写__init__方法添加自己的属性，使用super加载父类属性
				3. 重写run方法
		
		【2】 使用方法
				1. 实例化对象
				2. 调用start自动执行run方法
				3. 调用join回收线程


三. 线程通信

	【1】 通信方法 ： 线程间使用全局变量进行通信


  【2】 共享资源争夺

			1. 共享资源：多个进程或者线程都可以操作的资源称为共享资源。对共享资源的操作代码段称为临界区。

			2. 影响 ： 对共享资源的无序操作可能会带来数据的混乱，或者操作错误。此时往往需要同步互斥机制协调操作顺序。
	
	【3】 同步互斥机制

			同步 ： 同步是一种协作关系，为完成操作，多进程或者线程间形成一种协调，按照必要的步骤有序执行操作。

			互斥 ： 互斥是一种制约关系，当一个进程或者线程占有资源时会进行加锁处理，此时其他进程线程就无法操作该资源，直到解锁后才能操作。
  
	【4】 线程同步互斥方法

			1. 线程Event
			  
				from threading import Event

				e = Event()  创建线程event对象

				e.wait([timeout])  阻塞等待e被set

				e.set()  设置e，使wait结束阻塞

				e.clear() 使e回到未被设置状态

				e.is_set()  查看当前e是否被设置


			2. 线程锁 Lock

			  from  threading import Lock

				lock = Lock()  创建锁对象
				lock.acquire() 上锁  如果lock已经上锁再调用会阻塞
				lock.release() 解锁

				with  lock:  上锁
					...
					...
										 with代码块结束自动解锁


作业 ： 1. 对比进程线程的特点区别
				2. 做单进程，多进程，多线程的效率测试
				   利用测试程序，记录执行时间。